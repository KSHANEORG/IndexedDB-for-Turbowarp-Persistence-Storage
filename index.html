<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB Extension for TurboWarp</title>
    <style>
    * {
            font-family: sans-serif
    }
        
:root {
    --primary: #ffffff;  /* White accent */
    --secondary: #ff9c1a; /* Keeping orange as secondary */
    --dark: #121212;    /* Dark background */
    --light: #1e1e1e;   /* Slightly lighter dark for cards */
    --text: #e0e0e0;    /* Light text */
    --success: #4caf50; /* Green for success actions */
}

body {
    background-color: var(--dark);
    color: var(--text);
}

header {
    background: linear-gradient(135deg, #2a2a2a, #121212);
    color: var(--primary);
    border-bottom: 1px solid #333;
}

.feature-card, .example {
    background-color: var(--light);
    border: 1px solid #333;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.code-block {
    background-color: #252525;
    color: #f8f8f8;
    border-left: 4px solid var(--primary);
}

.block-preview {
    background-color: #2d2d2d;
    color: var(--primary);
    border-left: 4px solid var(--primary);
}

.cta-button {
    background-color: var(--primary);
    color: var(--dark);
}

.cta-button.secondary {
    background-color: transparent;
    color: var(--primary);
    border: 2px solid var(--primary);
}

.cta-button:hover {
    box-shadow: 0 6px 12px rgba(255, 255, 255, 0.1);
}

footer {
    background-color: #080808;
    border-top: 1px solid #333;
}

/* Syntax highlighting for code blocks */
.code-block {
    /* You might want to add proper syntax highlighting later */
    color: #d4d4d4;
}

/* Dark mode scrollbar */
::-webkit-scrollbar {
    width: 10px;
}

::-webkit-scrollbar-track {
    background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
    background: #444;
    border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
    background: #555;
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>IndexedDB Extension for TurboWarp</h1>
            <p class="subtitle">Powerful client-side database storage for your Scratch projects. Save game progress, user preferences, and more!</p>
            <div>
                <a href="#install" class="cta-button">Get Started</a>
                <a href="#examples" class="cta-button secondary">See Examples</a>
            </div>
        </div>
    </header>
    
    <section id="features">
        <div class="container">
            <h2>Why Use IndexedDB?</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <i class="fas fa-database"></i>
                    <h3>Persistent Storage</h3>
                    <p>Save data that persists between sessions, even when the browser is closed.</p>
                </div>
                <div class="feature-card">
                    <i class="fas fa-tachometer-alt"></i>
                    <h3>Large Capacity</h3>
                    <p>Store significantly more data than localStorage (typically 50% of disk space).</p>
                </div>
                <div class="feature-card">
                    <i class="fas fa-search"></i>
                    <h3>Fast Indexed Queries</h3>
                    <p>Quickly find data using indexed properties for better performance.</p>
                </div>
                <div class="feature-card">
                    <i class="fas fa-mobile-alt"></i>
                    <h3>Offline Support</h3>
                    <p>Perfect for Progressive Web Apps (PWAs) and offline-capable projects.</p>
                </div>
                <div class="feature-card">
                    <i class="fas fa-table"></i>
                    <h3>Structured Data</h3>
                    <p>Store complex objects instead of just strings like in localStorage.</p>
                </div>
                <div class="feature-card">
                    <i class="fas fa-shield-alt"></i>
                    <h3>Secure</h3>
                    <p>Data is sandboxed to your domain and can't be accessed by other sites.</p>
                </div>
            </div>
        </div>
    </section>
    
    <section id="install">
        <div class="container">
            <h2>Installation</h2>
            <p>To use the IndexedDB extension in TurboWarp:</p>
            
            <div class="example">
                <h3>Method 1: Load from URL</h3>
                <ol>
                    <li>Open your project in TurboWarp</li>
                    <li>Click "Extensions" in the toolbar</li>
                    <li>Select "Load Extension"</li>
                    <li>Enter the extension URL (indexeddb.kenzieshane.my.id/indexeddb.js)</li>
                </ol>
            </div>
            
            <div class="example">
                <h3>Method 2: Manual Setup</h3>
                <p>Copy this JavaScript code into a new extension file:</p>
                <div class="code-block" id="full-code">
                    class IndexedDBExtension {
  constructor(runtime) {
    this.runtime = runtime;
    this.databases = {};
    this.currentDB = null;
  }

  getInfo() {
    return {
      id: 'indexeddb',
      name: 'IndexedDB',
      blocks: [
        // Database Management
        {
          opcode: 'openDatabase',
          blockType: Scratch.BlockType.COMMAND,
          text: 'open database [name] version [version]',
          arguments: {
            name: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'scratch_data'
            },
            version: {
              type: Scratch.ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        },
        {
          opcode: 'deleteDatabase',
          blockType: Scratch.BlockType.COMMAND,
          text: 'delete entire database [name]',
          arguments: {
            name: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'scratch_data'
            }
          }
        },
        {
          opcode: 'listDatabases',
          blockType: Scratch.BlockType.REPORTER,
          text: 'list all databases'
        },

        // Store Management
        {
          opcode: 'listStores',
          blockType: Scratch.BlockType.REPORTER,
          text: 'list all stores in current database'
        },
        {
          opcode: 'createStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'create store [storeName] with options [options]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'new_store'
            },
            options: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'keyPath: "id", autoIncrement: true'
            }
          }
        },
        {
          opcode: 'deleteStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'delete store [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'old_data'
            }
          }
        },
        {
          opcode: 'countRecords',
          blockType: Scratch.BlockType.REPORTER,
          text: 'count records in [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            }
          }
        },
        {
          opcode: 'clearStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'clear ALL records in [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            }
          }
        },

        // Data Operations
        {
          opcode: 'storeData',
          blockType: Scratch.BlockType.COMMAND,
          text: 'store in [storeName] key [key] value [value]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            },
            key: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myKey'
            },
            value: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myValue'
            }
          }
        },
        {
          opcode: 'getData',
          blockType: Scratch.BlockType.REPORTER,
          text: 'get from [storeName] key [key]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            },
            key: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myKey'
            }
          }
        }
      ],
      menus: {
        options: {
          acceptReporters: true,
          items: [
            'keyPath: "id", autoIncrement: false',
            'keyPath: "id", autoIncrement: true',
            'keyPath: null, autoIncrement: true'
          ]
        }
      }
    };
  }

  // Database Operations
  openDatabase(args) {
    return new Promise((resolve) => {
      const request = indexedDB.open(args.name, args.version);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('default')) {
          db.createObjectStore('default');
        }
      };
      
      request.onsuccess = (event) => {
        this.currentDB = event.target.result;
        this.databases[args.name] = this.currentDB;
        resolve();
      };
      
      request.onerror = (event) => {
        console.error('Database error:', event.target.error);
        resolve();
      };
    });
  }

  deleteDatabase(args) {
    return new Promise((resolve) => {
      if (this.currentDB && this.currentDB.name === args.name) {
        this.currentDB.close();
        this.currentDB = null;
      }
      
      const request = indexedDB.deleteDatabase(args.name);
      
      request.onsuccess = () => {
        delete this.databases[args.name];
        resolve();
      };
      
      request.onerror = (event) => {
        console.error('Delete error:', event.target.error);
        resolve();
      };
    });
  }

  listDatabases() {
    return new Promise((resolve) => {
      // Note: This uses a non-standard but widely supported method
      if (indexedDB.databases) {
        indexedDB.databases().then(dbs => {
          resolve(dbs.map(db => db.name).join(', '));
        }).catch(() => resolve(''));
      } else {
        // Fallback: Only list databases we've opened
        resolve(Object.keys(this.databases).join(', '));
      }
    });
  }

  // Store Operations
  listStores() {
    if (!this.currentDB) return '';
    return Array.from(this.currentDB.objectStoreNames).join(', ');
  }

  createStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const db = this.currentDB;
      const version = db.version + 1;
      db.close();
      
      const req = indexedDB.open(db.name, version);
      
      req.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(args.storeName)) {
          try {
            const options = JSON.parse(`{${args.options}}`);
            db.createObjectStore(args.storeName, options);
          } catch (e) {
            db.createObjectStore(args.storeName);
          }
        }
      };
      
      req.onsuccess = (event) => {
        this.currentDB = event.target.result;
        this.databases[db.name] = this.currentDB;
        resolve();
      };
    });
  }

  deleteStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const db = this.currentDB;
      const version = db.version + 1;
      db.close();
      
      const req = indexedDB.open(db.name, version);
      
      req.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains(args.storeName)) {
          db.deleteObjectStore(args.storeName);
        }
      };
      
      req.onsuccess = (event) => {
        this.currentDB = event.target.result;
        resolve();
      };
    });
  }

  countRecords(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve(0);
        return;
      }
      
      const transaction = this.currentDB.transaction(args.storeName, 'readonly');
      const store = transaction.objectStore(args.storeName);
      const request = store.count();
      
      request.onsuccess = () => {
        resolve(request.result);
      };
      
      request.onerror = () => {
        resolve(0);
      };
    });
  }

  clearStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const transaction = this.currentDB.transaction(args.storeName, 'readwrite');
      const store = transaction.objectStore(args.storeName);
      const request = store.clear();
      
      request.onsuccess = () => {
        resolve();
      };
      
      request.onerror = () => {
        resolve();
      };
    });
  }

  // Data Operations
  storeData(args) {
    if (!this.currentDB) return Promise.resolve();
    
    return new Promise((resolve) => {
      const transaction = this.currentDB.transaction(args.storeName, 'readwrite');
      const store = transaction.objectStore(args.storeName);
      store.put(args.value, args.key);
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => resolve();
    });
  }

  getData(args) {
    if (!this.currentDB) return Promise.resolve('');
    
    return new Promise((resolve) => {
      const transaction = this.currentDB.transaction(args.storeName, 'readonly');
      const store = transaction.objectStore(args.storeName);
      const request = store.get(args.key);
      
      request.onsuccess = () => {
        resolve(request.result != null ? request.result : '');
      };
      
      request.onerror = () => {
        resolve('');
      };
    });
  }
}

Scratch.extensions.register(new IndexedDBExtension());
                </div>
                <button onclick="copyCode()" class="cta-button" style="background-color: var(--success); color: white;">
                    <i class="fas fa-copy"></i> Copy Code
                </button>
            </div>
        </div>
    </section>
    
    <section id="documentation">
        <div class="container">
            <h2>Documentation</h2>
            
            <h3>Database Management</h3>
            <div class="block-preview">
                open database [name] version [1]
            </div>
            <p>Opens or creates a database. Version must be an integer (increase when changing structure).</p>
            
            <div class="block-preview">
                delete entire database [name]
            </div>
            <p>Permanently removes a database and all its data.</p>
            
            <div class="block-preview">
                list all databases
            </div>
            <p>Returns a list of all available databases (reporter block).</p>
            
            <h3>Store (Table) Management</h3>
            <div class="block-preview">
                create store [name] with options [options]
            </div>
            <p>Creates a new object store. Options can specify key paths and auto-increment settings.</p>
            
            <div class="block-preview">
                delete store [name]
            </div>
            <p>Removes an object store and all its data.</p>
            
            <div class="block-preview">
                clear ALL records in [store]
            </div>
            <p>Deletes all data in a store while keeping the store itself.</p>
            
            <h3>Data Operations</h3>
            <div class="block-preview">
                store in [store] key [key] value [value]
            </div>
            <p>Saves data with a specific key for later retrieval.</p>
            
            <div class="block-preview">
                get from [store] key [key]
            </div>
            <p>Retrieves previously stored data (reporter block).</p>
        </div>
    </section>
    
    <section id="examples">
        <div class="container">
            <h2>Example Projects</h2>
            
            <div class="example">
                <h3>Game Save System</h3>
                <div class="code-block">
when green flag clicked
open database "game_saves" version 1
wait until &lt;not &lt;(current database) = [null]>> // Wait for DB to load
                </div>
                
                <div class="code-block">
when [s v] key pressed // Save game
store in "player" key "level" value (level)
store in "player" key "score" value (score)
store in "player" key "inventory" value (inventory)
                </div>
                
                <div class="code-block">
when [l v] key pressed // Load game
set [level] to (get from "player" key "level")
set [score] to (get from "player" key "score")
set [inventory] to (get from "player" key "inventory")
                </div>
            </div>
            
            <div class="example">
                <h3>User Preferences</h3>
                <div class="code-block">
when green flag clicked
open database "settings" version 1
                </div>
                
                <div class="code-block">
when [volume v] slider changed // Save volume
store in "prefs" key "volume" value (volume)
                </div>
                
                <div class="code-block">
when I receive [load settings]
set [volume] to (get from "prefs" key "volume")
set [theme] to (get from "prefs" key "theme")
                </div>
            </div>
        </div>
    </section>
    
    <section>
        <div class="container">
            <h2>Frequently Asked Questions</h2>
            
            <div class="example">
                <h3>Where is the data stored?</h3>
                <p>Data is stored in the browser's IndexedDB system, which persists even after closing the browser.</p>
            </div>
            
            <div class="example">
                <h3>Is there a storage limit?</h3>
                <p>Most browsers allow up to 50% of disk space, but exact limits vary by browser and device.</p>
            </div>
            
            <div class="example">
                <h3>Can I share data between different projects?</h3>
                <p>Yes, if they use the same database name and are hosted on the same domain.</p>
            </div>
        </div>
    </section>
    
    <footer>
        <div class="container">
            <p>IndexedDB Extension for TurboWarp</p>
            <p>Created with ❤️ for Scratch enthusiasts</p>
            <p>Free to use and modify</p>
        </div>
    </footer>
    
    <script>
        // This would contain the actual extension code
        const extensionCode = `class IndexedDBExtension {
  constructor(runtime) {
    this.runtime = runtime;
    this.databases = {};
    this.currentDB = null;
  }

  getInfo() {
    return {
      id: 'indexeddb',
      name: 'IndexedDB',
      blocks: [
        // Database Management
        {
          opcode: 'openDatabase',
          blockType: Scratch.BlockType.COMMAND,
          text: 'open database [name] version [version]',
          arguments: {
            name: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'scratch_data'
            },
            version: {
              type: Scratch.ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        },
        {
          opcode: 'deleteDatabase',
          blockType: Scratch.BlockType.COMMAND,
          text: 'delete entire database [name]',
          arguments: {
            name: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'scratch_data'
            }
          }
        },
        {
          opcode: 'listDatabases',
          blockType: Scratch.BlockType.REPORTER,
          text: 'list all databases'
        },

        // Store Management
        {
          opcode: 'listStores',
          blockType: Scratch.BlockType.REPORTER,
          text: 'list all stores in current database'
        },
        {
          opcode: 'createStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'create store [storeName] with options [options]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'new_store'
            },
            options: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'keyPath: "id", autoIncrement: true'
            }
          }
        },
        {
          opcode: 'deleteStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'delete store [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'old_data'
            }
          }
        },
        {
          opcode: 'countRecords',
          blockType: Scratch.BlockType.REPORTER,
          text: 'count records in [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            }
          }
        },
        {
          opcode: 'clearStore',
          blockType: Scratch.BlockType.COMMAND,
          text: 'clear ALL records in [storeName]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            }
          }
        },

        // Data Operations
        {
          opcode: 'storeData',
          blockType: Scratch.BlockType.COMMAND,
          text: 'store in [storeName] key [key] value [value]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            },
            key: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myKey'
            },
            value: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myValue'
            }
          }
        },
        {
          opcode: 'getData',
          blockType: Scratch.BlockType.REPORTER,
          text: 'get from [storeName] key [key]',
          arguments: {
            storeName: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'default'
            },
            key: {
              type: Scratch.ArgumentType.STRING,
              defaultValue: 'myKey'
            }
          }
        }
      ],
      menus: {
        options: {
          acceptReporters: true,
          items: [
            'keyPath: "id", autoIncrement: false',
            'keyPath: "id", autoIncrement: true',
            'keyPath: null, autoIncrement: true'
          ]
        }
      }
    };
  }

  // Database Operations
  openDatabase(args) {
    return new Promise((resolve) => {
      const request = indexedDB.open(args.name, args.version);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('default')) {
          db.createObjectStore('default');
        }
      };
      
      request.onsuccess = (event) => {
        this.currentDB = event.target.result;
        this.databases[args.name] = this.currentDB;
        resolve();
      };
      
      request.onerror = (event) => {
        console.error('Database error:', event.target.error);
        resolve();
      };
    });
  }

  deleteDatabase(args) {
    return new Promise((resolve) => {
      if (this.currentDB && this.currentDB.name === args.name) {
        this.currentDB.close();
        this.currentDB = null;
      }
      
      const request = indexedDB.deleteDatabase(args.name);
      
      request.onsuccess = () => {
        delete this.databases[args.name];
        resolve();
      };
      
      request.onerror = (event) => {
        console.error('Delete error:', event.target.error);
        resolve();
      };
    });
  }

  listDatabases() {
    return new Promise((resolve) => {
      // Note: This uses a non-standard but widely supported method
      if (indexedDB.databases) {
        indexedDB.databases().then(dbs => {
          resolve(dbs.map(db => db.name).join(', '));
        }).catch(() => resolve(''));
      } else {
        // Fallback: Only list databases we've opened
        resolve(Object.keys(this.databases).join(', '));
      }
    });
  }

  // Store Operations
  listStores() {
    if (!this.currentDB) return '';
    return Array.from(this.currentDB.objectStoreNames).join(', ');
  }

  createStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const db = this.currentDB;
      const version = db.version + 1;
      db.close();
      
      const req = indexedDB.open(db.name, version);
      
      req.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(args.storeName)) {
          try {
            const options = JSON.parse(`{${args.options}}`);
            db.createObjectStore(args.storeName, options);
          } catch (e) {
            db.createObjectStore(args.storeName);
          }
        }
      };
      
      req.onsuccess = (event) => {
        this.currentDB = event.target.result;
        this.databases[db.name] = this.currentDB;
        resolve();
      };
    });
  }

  deleteStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const db = this.currentDB;
      const version = db.version + 1;
      db.close();
      
      const req = indexedDB.open(db.name, version);
      
      req.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains(args.storeName)) {
          db.deleteObjectStore(args.storeName);
        }
      };
      
      req.onsuccess = (event) => {
        this.currentDB = event.target.result;
        resolve();
      };
    });
  }

  countRecords(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve(0);
        return;
      }
      
      const transaction = this.currentDB.transaction(args.storeName, 'readonly');
      const store = transaction.objectStore(args.storeName);
      const request = store.count();
      
      request.onsuccess = () => {
        resolve(request.result);
      };
      
      request.onerror = () => {
        resolve(0);
      };
    });
  }

  clearStore(args) {
    return new Promise((resolve) => {
      if (!this.currentDB) {
        resolve();
        return;
      }
      
      const transaction = this.currentDB.transaction(args.storeName, 'readwrite');
      const store = transaction.objectStore(args.storeName);
      const request = store.clear();
      
      request.onsuccess = () => {
        resolve();
      };
      
      request.onerror = () => {
        resolve();
      };
    });
  }

  // Data Operations
  storeData(args) {
    if (!this.currentDB) return Promise.resolve();
    
    return new Promise((resolve) => {
      const transaction = this.currentDB.transaction(args.storeName, 'readwrite');
      const store = transaction.objectStore(args.storeName);
      store.put(args.value, args.key);
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => resolve();
    });
  }

  getData(args) {
    if (!this.currentDB) return Promise.resolve('');
    
    return new Promise((resolve) => {
      const transaction = this.currentDB.transaction(args.storeName, 'readonly');
      const store = transaction.objectStore(args.storeName);
      const request = store.get(args.key);
      
      request.onsuccess = () => {
        resolve(request.result != null ? request.result : '');
      };
      
      request.onerror = () => {
        resolve('');
      };
    });
  }
}

Scratch.extensions.register(new IndexedDBExtension());`;

        // Display the code in the code block
        document.getElementById('full-code').textContent = extensionCode;
        
        // Copy functionality
        function copyCode() {
            navigator.clipboard.writeText(extensionCode).then(() => {
                alert('Code copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }
    </script>
</body>
</html>
